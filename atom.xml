<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.H&#39;s blog</title>
  
  <subtitle>ambition</subtitle>
  <link href="https://hyong1232.github.io/atom.xml" rel="self"/>
  
  <link href="https://hyong1232.github.io/"/>
  <updated>2020-10-29T14:06:20.000Z</updated>
  <id>https://hyong1232.github.io/</id>
  
  <author>
    <name>Mr.H</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack和babel在项目中的应用</title>
    <link href="https://hyong1232.github.io/2020/10/13/webpack-he-babel-zai-xiang-mu-zhong-de-ying-yong/"/>
    <id>https://hyong1232.github.io/2020/10/13/webpack-he-babel-zai-xiang-mu-zhong-de-ying-yong/</id>
    <published>2020-10-13T06:58:25.000Z</published>
    <updated>2020-10-29T14:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用vue-cli简单不少，但要是单纯想使用es6的打包工具webpack和转换代码工具的babel进行项目的打包转换，麻烦不少</p><a id="more"></a><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><pre class="line-numbers language-shell-session"><code class="language-shell-session">//如果项目文件夹存在，可以省略项目名称npm init -y [项目名称]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用上述命令生成package.json文件，此文件主要记录了项目的依赖，版本号等信息。当项目丢失部分依赖时可使用npm install依照此记录重新安装依赖。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>webpack和babel的依赖包较多，且版本问题不兼容，很坑。直接使用固定版本命令安装</p><ul><li>安装babel的相关依赖</li></ul><pre class="line-numbers language-shell-session"><code class="language-shell-session">npm i -D babel-core@6.26.x babel-loader@7.0.0 babel-plugin-transform-runtime@6.23.x babel-preset-env@1.7.x babel-polyfill<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装webpack相关的依赖</li></ul><pre class="line-numbers language-shell-session"><code class="language-shell-session">npm i -D webpack@4.43.x webpack-cli@3.3.x webpack-dev-server@3.11.x html-webpack-plugin@4.3.x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装css和字体文件相关的依赖</li></ul><pre class="line-numbers language-shell-session"><code class="language-shell-session">$ npm i -D node-sass@4.14.x sass-loader@8.0.x css-loader@3.5.x file-loader@6.0.x style-loader@1.2.x url-loader@4.1.x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置wepack"><a href="#配置wepack" class="headerlink" title="配置wepack"></a>配置wepack</h2><p>配置需要使用的babel转换环境和wepack打包配置，项目入口生成文件存放路径等</p><p>1、在项目的根目录下创建webpack.config.js文件</p><p>2、在文件中写如下配置即可，项目运行时会自动读取此文件的配置</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//commonjs 导入文件格式</span><span class="token keyword">const</span> htmlwebpackplugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">const</span> htmlwebplugin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">htmlwebpackplugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    filename<span class="token punctuation">:</span><span class="token string">'index.html'</span><span class="token punctuation">,</span>    template<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./src/index.html'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//安装node-sass特殊命令npm install node-sass -D --sass-binary-site=http://npm.taobao.org/mirrors/node-sass</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span><span class="token string">'development'</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>htmlwebplugin<span class="token punctuation">]</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span><span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>                 test<span class="token punctuation">:</span> <span class="token regex">/.js$/</span><span class="token punctuation">,</span>                 exclude<span class="token punctuation">:</span><span class="token regex">/node_modules/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span><span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span><span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span><span class="token punctuation">{</span>                        presets<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'env'</span><span class="token punctuation">,</span><span class="token string">'babel-polyfill'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'transform-runtime'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            localIdentName<span class="token punctuation">:</span> <span class="token string">'[path][name]-[local]-[hash:5]'</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'sass-loader'</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\.ttf|woff|woff2|eot|svg$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token string">'url-loader'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// {test:/\.css$/,use:['style-loader','css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]']}</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span>        alias<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token string">'@'</span><span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'$'</span><span class="token punctuation">:</span>__dirname        <span class="token punctuation">}</span><span class="token punctuation">,</span>        extensions<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span><span class="token string">'.jsx'</span><span class="token punctuation">,</span><span class="token string">'.json'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;使用vue-cli简单不少，但要是单纯想使用es6的打包工具webpack和转换代码工具的babel进行项目的打包转换，麻烦不少&lt;/p&gt;</summary>
    
    
    
    <category term="node" scheme="https://hyong1232.github.io/categories/node/"/>
    
    <category term="打包工具" scheme="https://hyong1232.github.io/categories/node/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="node" scheme="https://hyong1232.github.io/tags/node/"/>
    
    <category term="wepack,babel" scheme="https://hyong1232.github.io/tags/wepack-babel/"/>
    
  </entry>
  
  <entry>
    <title>python函数</title>
    <link href="https://hyong1232.github.io/2020/10/11/python-han-shu/"/>
    <id>https://hyong1232.github.io/2020/10/11/python-han-shu/</id>
    <published>2020-10-11T03:12:06.000Z</published>
    <updated>2020-10-25T13:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>介绍</p><a id="more"></a><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li>默认会返回值是None不是null</li></ul><table><thead><tr><th>api</th><th>释义</th></tr></thead><tbody><tr><td>int(String)</td><td>将字符串转化成数字</td></tr><tr><td>abs(number)</td><td>将数字转换成绝对值</td></tr><tr><td>max(params1,params2….)</td><td>多个参数，返回最大值</td></tr><tr><td>instance(any)</td><td>返回字符的类型</td></tr></tbody></table><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><blockquote><p>按照类型分为五类：必填参数、默认参数、可变参数、关键字参数、命名关键字参数，他们的<strong>组合顺序也是如此</strong></p></blockquote><ul><li><p>默认参数<br>  1、不可设置为可变变量（只能string/数字/None等），参数重加在不会重新赋值，会重复引用之前初始化定义的值（与es6区别）</p>  <pre><code>#错误的写法def variable_paramter_func(l &#x3D; []):    l.append(&#39;end&#39;)    print(l)#正确的写法def correct_variable_paramter_func(l&#x3D;None):    if not l:        l &#x3D; []    l.append(&#39;end&#39;)    print(l)variable_paramter_func()variable_paramter_func()#打印结果[&#39;end&#39;] [&#39;end&#39;&#39;end&#39;]correct_variable_paramter_func()correct_variable_paramter_func()#打印结果[&#39;end&#39;] [&#39;end&#39;]</code></pre><p>  2、可为普通位置参数和命名关键字参数赋值，赋值后即可不传（使用默认值）</p></li><li><p>可变参数&amp;关键字参数的赋值分别使用*()|<em>[]和\</em>*{a:’a’}格式，且赋值会复制新的对象，不改变源数据</p></li><li><p>命名关键字再参数列表前必须要有<em>分割（可变参数或单独加一个\</em>参数），命名关键字也是函数调用时的必传值</p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>函数调用使用stack栈实现，调用一次栈增加一层，所以会有递归的栈溢出，使用尾递归优化方法（return时调用函数本身，将结算结果一并传入函数）<strong>pythong没有优化，使用不使用没区别</strong><pre><code>#尾递归优化：求100到1之和def recursion_factorial(num, res):    if num &#x3D;&#x3D; 0:        return res    return recursion_factorial(num-1, res+num)print(recursion_factorial(100, 0))#输出5050</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;介绍&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://hyong1232.github.io/categories/python/"/>
    
    <category term="function" scheme="https://hyong1232.github.io/categories/python/function/"/>
    
    
    <category term="python" scheme="https://hyong1232.github.io/tags/python/"/>
    
    <category term="function" scheme="https://hyong1232.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>python的list和tuple</title>
    <link href="https://hyong1232.github.io/2020/10/11/python-de-list-he-tuple/"/>
    <id>https://hyong1232.github.io/2020/10/11/python-de-list-he-tuple/</id>
    <published>2020-10-10T16:29:18.000Z</published>
    <updated>2020-10-25T13:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>python中的list和tuple对象的基本用法，及常用api</p><a id="more"></a><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul><li>下标取/存值</li><li>pop([index])删除值（默认最后一位）</li><li>append(ele)添加元素至list末尾</li><li>insert(index,object)插入元素至指定位置</li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><ul><li>定义了就不可修改（类似es6的const关键字定义变量？）</li><li>在函数中应用：返回值是省略了小括号的元组，因此可以返回多个值<pre><code>def return_multi_params():    return 1,&#39;jack&#39;age,name &#x3D; return_multi_params()#name &#x3D; &#39;jack&#39;,age&#x3D;1</code></pre></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>if x:简写，判定不为空值|空字符串|<strong>空的list</strong> </li><li>elif 是else if简写</li><li>input([‘输出string’])函数，接收用户输入信息</li><li>int(string)&amp;str(num)字符转整数&amp;整数转字符函数</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li>遍历每一个list，for variable in list:</li><li>while 条件:</li><li>break/continue</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>初始化就是写一个json对</li><li>和list对比查找速度快，浪费空间（空间换时间）</li><li>pop([index])同list</li><li>get(key)==map[key]获取键对应值</li><li>key不可变（不能为list，可为string、整数）</li><li>储存的元素无序</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>储存的元素无序</li><li>创建:set([ele]),元组里面放一个list</li><li>元素不可变（可变对象难以比较是否相等，无法保证元素唯一性）</li><li>remove(key)</li><li>add(key)</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;python中的list和tuple对象的基本用法，及常用api&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://hyong1232.github.io/categories/python/"/>
    
    <category term="list&amp;tuple" scheme="https://hyong1232.github.io/categories/python/list-tuple/"/>
    
    
    <category term="python" scheme="https://hyong1232.github.io/tags/python/"/>
    
    <category term="list" scheme="https://hyong1232.github.io/tags/list/"/>
    
    <category term="tuple" scheme="https://hyong1232.github.io/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>python基本数据类型</title>
    <link href="https://hyong1232.github.io/2020/10/10/python-ji-ben-shu-ju-lei-xing/"/>
    <id>https://hyong1232.github.io/2020/10/10/python-ji-ben-shu-ju-lei-xing/</id>
    <published>2020-10-10T15:02:42.000Z</published>
    <updated>2020-10-25T14:24:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>决心开始认真系统学习python，基本数据类型开始，记录自己感觉重要的知识点。</p><a id="more"></a><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><ul><li><p>十六进制ox开头</p></li><li><p>允许使用_下划线分割多个0的大数据</p><pre><code>#等效写法100_000_000 &#x3D;&#x3D; 100000000</code></pre></li><li><p>整数运算永远是精确计算（除法也是），浮点数计算会有四舍五入误差</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>定义：使用单引号’’和双引号””包裹起来的数据</p></li><li><p>字符串和整数不可变，任何操作不会改变源数据，而是创建新的数据</p></li><li><p>使用’’’multi-line-string’’’包裹，表示多行字符串</p></li><li><p>默认会对包含\符号的字符转义转义，在字符串前加上r则不会转义</p></li><li><p><strong>字符串中的格式化处理</strong><br>  1、使用%占位符处理<br>  规则：字符串里面使用上述字符占位，在结尾使用%(replacement1,replacement2…)替换</p><table><thead><tr><th>字符</th><th>释义</th></tr></thead><tbody><tr><td>%s</td><td>普通字符</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%d</td><td>整数</td></tr><tr><td>%x</td><td>十六进制数</td></tr></tbody></table><p>  示例：</p>  <pre><code>print(&#39;%s is %d year\&#39;s old,he have $%f&#39; %(&#39;jack&#39;,23,3456345643.234))#使用%%转义%print(&#39;%%%d&#39;%25)</code></pre><p>  <strong>在字符串中可加入整数/浮点数在%和特定字符间对数据输出位数处理</strong></p>  <pre><code>#整数数字表示占位print(&#39;%3d&#39;%23)#浮点数对浮点数的位数处理print(&#39;%.2f&#39;%12.23453)</code></pre><p>  2、使用string类型的format函数配合{}</p>  <pre><code>print(&#39;{} is {} year\&#39;s old,he have ${}&#39;.format(&#39;jack&#39;,23,3456345643.234))</code></pre><p>  3、在字符串前加上f，然后使用{变量名}，自动替换字符串（类似es6中的反引号字符串）</p>  <pre><code>name &#x3D; &#39;jack&#39;age &#x3D; 23money &#x3D; 3456345643.234print(f&#39;{name} is {age} year\&#39;s old,he have ${money}&#39;)</code></pre></li></ul><h2 id="布尔值Boolean"><a href="#布尔值Boolean" class="headerlink" title="布尔值Boolean"></a>布尔值Boolean</h2><ul><li>值表示是首字符大写<pre><code>1&#x3D;&#x3D;2---&gt;False1&#x3D;&#x3D;1---&gt;True</code></pre></li></ul><h2 id="空置None"><a href="#空置None" class="headerlink" title="空置None"></a>空置None</h2><ul><li>与js的null区别开</li></ul><h2 id="变量-amp-amp-常量"><a href="#变量-amp-amp-常量" class="headerlink" title="变量&amp;&amp;常量"></a>变量&amp;&amp;常量</h2><ul><li>变量不必声明，常量的变量名称全部大写（说是常量其实随时可变）</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>使用#做标志</p></li><li><p>通用注释</p><pre><code>#告诉python解释器（cpython用的最多）以utf-8格式读取文件#-*- coding:utf-8 -*-#告诉Linux和mac是一个可执行的python文件（win不支持） #!user&#x2F;bin&#x2F;env python3</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;决心开始认真系统学习python，基本数据类型开始，记录自己感觉重要的知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://hyong1232.github.io/categories/python/"/>
    
    <category term="基本数据类型" scheme="https://hyong1232.github.io/categories/python/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="python" scheme="https://hyong1232.github.io/tags/python/"/>
    
    <category term="基本数据类型" scheme="https://hyong1232.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java-day8</title>
    <link href="https://hyong1232.github.io/2020/10/09/java-day8/"/>
    <id>https://hyong1232.github.io/2020/10/09/java-day8/</id>
    <published>2020-10-08T16:05:21.000Z</published>
    <updated>2020-10-25T14:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第八天，决心改掉恶习，加油！</p><a id="more"></a><h2 id="HashMap常用api"><a href="#HashMap常用api" class="headerlink" title="HashMap常用api"></a>HashMap常用api</h2><table><thead><tr><th>api</th><th>释义</th><th>返回值</th></tr></thead><tbody><tr><td>get(key)</td><td>获取指定键值对应的值，key为未保存的值时返回null值</td><td>正常指定键对应的值，key不存在返回null值</td></tr><tr><td>put(key,value)</td><td>添加指定的键值对，key和value均可为null值，重复保存相同的键而值不同则会覆盖</td><td>正常null，覆盖保存返回被覆盖的值</td></tr><tr><td>remove(key)</td><td>删除指定键值对，key为未保存的值时返回null值</td><td>被删除的值</td></tr><tr><td>size()</td><td>获取map存储的键值对个数</td><td>-</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;第八天，决心改掉恶习，加油！&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://hyong1232.github.io/categories/java/"/>
    
    <category term="Collection" scheme="https://hyong1232.github.io/categories/java/Collection/"/>
    
    
    <category term="java" scheme="https://hyong1232.github.io/tags/java/"/>
    
    <category term="HashMap" scheme="https://hyong1232.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="https://hyong1232.github.io/2020/10/07/npm-chang-yong-ming-ling/"/>
    <id>https://hyong1232.github.io/2020/10/07/npm-chang-yong-ming-ling/</id>
    <published>2020-10-07T03:56:29.000Z</published>
    <updated>2020-10-25T13:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>npm包管理工具的命令较多，记录下常用的命令</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>详见 <strong><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm使用指南</a></strong> 阮一峰先生写的npm原理很清楚，通俗易懂。总结起来就是在运行npm run+关键字的命令时，npm会自动创建一个shell，同时将/node_moudles/.bin文件加到Path路径下，从而执行.bin文件里面的脚本代码（支持所有shell脚本，不仅是node的脚本）</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>释义</th><th>简写</th></tr></thead><tbody><tr><td>npm install</td><td>初始化项目/安装项目的依赖</td><td>-</td></tr><tr><td>npm install -y</td><td>初始化项目，创建package.json文件（执行默认选项）</td><td>-</td></tr><tr><td>npm install [包名@版本号] [--global]</td><td>安装指定名称的依赖（可指定以来的版本），首次安装会自动创建node_modules文件夹（所有依赖均安装至此），global关键字指定是否是全局安装</td><td>npm i -g [包名@版本号]</td></tr><tr><td>npm run [script]</td><td>执行package.json文件中指定的脚本</td><td>-</td></tr><tr><td>npm install –save-dev [包名@版本号]</td><td>安装依赖并只在开发阶段使用，会在packjson的devDependencies属性下做标识（不加--save会在dependencies属性下做标识）</td><td>npm i -D [包名@版本号]</td></tr><tr><td>npm help</td><td>查询所有的npm命令</td><td>-</td></tr><tr><td>npm uninstall –save [包名@版本号]</td><td>卸载依赖，并清除package.json中的文本中dependencies属性下记录的依赖信息</td><td>npm un -S [包名@版本号]</td></tr><tr><td>npm uninstall –save-dev [包名@版本号]</td><td>卸载node_moudles下的依赖文件，并清除devDependencies属性下记录的依赖信息</td><td>npm un -D [包名@版本号]</td></tr><tr><td>npm update [-g] [包名@版本号]</td><td>升级依赖包（可升级全局安装的依赖）</td><td>-</td></tr><tr><td>npm i -g cnpm</td><td>安装淘宝npm镜像</td><td>-</td></tr><tr><td>npm i -S [包名@版本号] –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></td><td>从淘宝镜像源安装依赖</td><td>-</td></tr><tr><td>npm confit set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></td><td>设置npm安装依赖的路径为淘宝镜像源</td><td>-</td></tr><tr><td>npm config list</td><td>显示npm配置列表</td><td>-</td></tr><tr><td>npm config ls -l</td><td>显示所有npm配置列表</td><td>-</td></tr></tbody></table><ul><li>关于npx可见<strong>阮一峰先生的教程<a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">npx使用教程</a></strong></li><li>安装多个依赖使用空格隔开依赖包名称即可</li><li>使用&amp;链接多个npm命令——不分先后同时执行，使用&amp;&amp;链接多个npm命令——依次执行npm命令</li></ul><h3 id="依赖包版本号中的特殊字符"><a href="#依赖包版本号中的特殊字符" class="headerlink" title="依赖包版本号中的特殊字符"></a>依赖包版本号中的特殊字符</h3><blockquote><p>依赖包的后面可接版本号，通常格式为；包名+特殊字符+版本号[major, minor, patch]</p></blockquote><p>1、特殊字符^<br>详见**二不挂五先生的文章<a href="https://zhuanlan.zhihu.com/p/66039729">npm install 版本号^的坑</a>**，简单点来说就是^标识的范围是版本号[major, minor, patch]中从左到右第一个非0位开始，小于此非零位+1的版本号</p><pre><code>^1.2.3版本包括：&gt;&#x3D; 1.2.3 并且 &lt; 2.0.0^0.2.3版本包括：&gt;&#x3D; 0.2.3 并且 &lt; 0.3.0^0.0.3版本包括：&gt;&#x3D; 0.0.3 并且 &lt; 0.0.4</code></pre><p>2、特殊字符~<br>与^类似，~字符则指定匹配版本号[major, minor, patch]中最新的patch位包依赖（方便修复小bug后依然适用于代码）</p><pre><code>~1.2.3版本包括：&gt;&#x3D; 1.2.3 并且 &lt; 1.3.0~0.2.3版本包括：&gt;&#x3D; 0.2.3 并且 &lt; 0.3.0~0.0.3版本包括：&gt;&#x3D; 0.0.3 并且 &lt; 0.1.0</code></pre><p>3、特殊字符@<br>在@后面可以添加具体的版本号，以指定依赖包的确切版本，@latest表示安装最新的依赖包</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;npm包管理工具的命令较多，记录下常用的命令&lt;/p&gt;</summary>
    
    
    
    <category term="node" scheme="https://hyong1232.github.io/categories/node/"/>
    
    <category term="npm" scheme="https://hyong1232.github.io/categories/node/npm/"/>
    
    
    <category term="node" scheme="https://hyong1232.github.io/tags/node/"/>
    
    <category term="npm" scheme="https://hyong1232.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli使用</title>
    <link href="https://hyong1232.github.io/2020/09/26/vue-cli-shi-yong/"/>
    <id>https://hyong1232.github.io/2020/09/26/vue-cli-shi-yong/</id>
    <published>2020-09-26T11:22:10.000Z</published>
    <updated>2020-10-25T13:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用于vue-cli的升级较快，记录下变化</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>#全局安装npm install -g @vue&#x2F;cli#升级项目中的cli相关模块#vue  upgrade [options] [plugin-name]#（试用）升级 Vue CLI 服务及插件#选项：  -t, --to &lt;version&gt;    升级 &lt;plugin-name&gt; 到指定的版本  -f, --from &lt;version&gt;  跳过本地版本检测，默认插件是从此处指定的版本升级上来  -r, --registry &lt;url&gt;  使用指定的 registry 地址安装依赖  --all                 升级所有的插件  --next                检查插件新版本时，包括 alpha&#x2F;beta&#x2F;rc 版本在内  -h, --help            输出帮助内容</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code>vue create [options] &lt;app-name&gt;#创建一个由 &#96;vue-cli-service&#96; 提供支持的新项目#选项：  -p, --preset &lt;presetName&gt;       忽略提示符并使用已保存的或远程的预设选项  -d, --default                   忽略提示符并使用默认预设选项  -i, --inlinePreset &lt;json&gt;       忽略提示符并使用内联的 JSON 字符串预设选项  -m, --packageManager &lt;command&gt;  在安装依赖时使用指定的 npm 客户端  -r, --registry &lt;url&gt;            在安装依赖时使用指定的 npm registry  -g, --git [message]             强制 &#x2F; 跳过 git 初始化，并可选的指定初始化提交信息  -n, --no-git                    跳过 git 初始化  -f, --force                     覆写目标目录可能存在的配置  -c, --clone                     使用 git clone 获取远程预设选项  -x, --proxy                     使用指定的代理创建项目  -b, --bare                      创建项目时省略默认组件中的新手指导信息  -h, --help                      输出使用帮助信息</code></pre><ul><li>需要使用vue-init功能，安装@vue/cli-init包即可</li><li>使用图像化创建项目<pre><code>vue ui</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;用于vue-cli的升级较快，记录下变化&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://hyong1232.github.io/categories/vue/"/>
    
    <category term="vue-cli" scheme="https://hyong1232.github.io/categories/vue/vue-cli/"/>
    
    
    <category term="vue" scheme="https://hyong1232.github.io/tags/vue/"/>
    
    <category term="vue-cli" scheme="https://hyong1232.github.io/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue文档记录</title>
    <link href="https://hyong1232.github.io/2020/09/25/vue-wen-dang-ji-lu/"/>
    <id>https://hyong1232.github.io/2020/09/25/vue-wen-dang-ji-lu/</id>
    <published>2020-09-25T02:51:57.000Z</published>
    <updated>2020-10-25T13:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>开始重新阅读vue官方文档，记录下重点内容，加强理解和记忆。</p><a id="more"></a><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><p>1、使用场景：模板内表达式的复杂计算</p><p>2、特性：响应式计算（不重复计算相同值，缓存响应式的依赖，即data中的值改变才重新计算，否则使用缓存值）优于方法和watch监听属性</p><p>示例：</p><pre><code>var vm &#x3D; new Vue({    data:{        firstname:&#39;foo&#39;,        lastname:&#39;bar&#39;    },    computed:{        fullname(){            return this.firstname+&#39;  &#39;+this.lastname        }    },    template:&#96;        &lt;div&gt;&lt;&#x2F;div&gt;    &#96;}).$mount(&#39;#app&#39;)</code></pre><p>3、自定义setter方法：一般计算属性默认只有getter方法，但支持添加setter方法，example</p><pre><code>...computed:{    fullname:{        get:function(){            return this.firstname+&#39; &#39;+this.lastname        },        set:function(newVal){            let nameArr &#x3D; newVal.split(&#39; &#39;)            this.firstname &#x3D; nameArr[0]            this.lastname &#x3D; nameArr[nameArr.length-1]        }    }}...&#x2F;&#x2F;改变fullname则会调用setter方法vm.fullname &#x3D; &#39;jack ma&#39;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;开始重新阅读vue官方文档，记录下重点内容，加强理解和记忆。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://hyong1232.github.io/categories/vue/"/>
    
    <category term="vue文档" scheme="https://hyong1232.github.io/categories/vue/vue%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="vue" scheme="https://hyong1232.github.io/tags/vue/"/>
    
    <category term="vue文档" scheme="https://hyong1232.github.io/tags/vue%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>常用css设置</title>
    <link href="https://hyong1232.github.io/2020/09/24/chang-yong-css-she-zhi/"/>
    <id>https://hyong1232.github.io/2020/09/24/chang-yong-css-she-zhi/</id>
    <published>2020-09-24T01:58:33.000Z</published>
    <updated>2020-10-25T14:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>列举常见的css命令，用于特定的功能。</p><a id="more"></a><h2 id="文本用超过使用…表示"><a href="#文本用超过使用…表示" class="headerlink" title="文本用超过使用…表示"></a>文本用超过使用…表示</h2><p>1、单行显示省略号</p><pre><code>selector{    overflow:hidden;    text-overflow:ellipsis;&#x2F;&#x2F;使用省略号代替截断文字    white-space:nowrap;&#x2F;&#x2F;不换行}</code></pre><p>2、多行显示（适用于chrome内核的浏览器）</p><pre><code>selector{    overflow:hidden;    text-overflow:ellipsis;    display:-webkit-box;&#x2F;&#x2F;显示格式为弹性伸缩盒子    -webkit-box-orient:vertical;&#x2F;&#x2F;元素内部排列方式    -webkit-line-clamp:2;&#x2F;&#x2F;显示的文本行数（非标准属性，与上面两个属性结合才可使用）}</code></pre><h2 id="将元素设置为吸顶模式"><a href="#将元素设置为吸顶模式" class="headerlink" title="将元素设置为吸顶模式"></a>将元素设置为吸顶模式</h2><pre><code>selector{    }</code></pre><h2 id="将元素设置为内敛模式"><a href="#将元素设置为内敛模式" class="headerlink" title="将元素设置为内敛模式"></a>将元素设置为内敛模式</h2><pre><code>selector{    box-sizing:content-box;默认    box-sizing:border-box;&#x2F;&#x2F;设置为内敛模式}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;列举常见的css命令，用于特定的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="https://hyong1232.github.io/categories/css/"/>
    
    <category term="css常用设置" scheme="https://hyong1232.github.io/categories/css/css%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"/>
    
    
    <category term="css" scheme="https://hyong1232.github.io/tags/css/"/>
    
    <category term="css常用设置" scheme="https://hyong1232.github.io/tags/css%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign函数</title>
    <link href="https://hyong1232.github.io/2020/09/23/object-assign-han-shu/"/>
    <id>https://hyong1232.github.io/2020/09/23/object-assign-han-shu/</id>
    <published>2020-09-23T09:05:02.000Z</published>
    <updated>2020-10-25T13:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>**Object.assign()**方法使用target的setter方法和origin对象的getter方法，复制对象可枚举的属性值，适用于很多的object操作。</p><a id="more"></a><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>1、复制对象值，并返回新创建新对象</p><pre><code>Object.assign({},{a:&#39;a&#39;},{b:&#39;b&#39;})</code></pre><p>2、为对象添加新属性</p><pre><code>Object.assign(orgin,{add:&#39;add&#39;})</code></pre><p>3、为对象添加新方法</p><pre><code>const obj &#x3D; {    val:&#39;val&#39;,}Object.assign(obj.prototype,{    getName(){        ....    }})</code></pre><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>1、由于Object.assign采用的是浅拷贝，因此源对象的属性值是对象时，只是复制了引用，再后面的复制中出现此对象的修改，则直接替换他的引用</p><pre><code>const obj1 &#x3D; {a: {b: 1}};const obj2 &#x3D; Object.assign({}, obj1);obj1.a.b &#x3D; 2;obj2.a.b &#x2F;&#x2F; 2</code></pre><p>2、不能复制origin源对象的继承属性，只能同通过Object.getPrototypeOf(origin)+Object.create()+origin方法，将其继承的方法单独调出来，然后合并</p><pre><code>let originProto &#x3D; Object.getPrototypeOf(origin);return Object.assign(Object.create(originProto), origin);</code></pre><p>3、target/orgin对象为非对象</p><ul><li> target为非对象，转换成对象，如果是null/undefined不可转换成对象的属性时，报错</li><li>origin为非对象时，自动转换，如果是null/undefined不可转换成对象的属性时，直接跳过</li></ul><p>4、数组处理</p><blockquote><p>将数组当成对象处理，键值为index下标</p></blockquote><pre><code>Object.assign([1,2,3],[4,5])&#x3D;&gt;[4,5,3]</code></pre><p>5、取值函数处理（关键字get开头）</p><blockquote><p>直接取值，不会获取取值函数合并</p></blockquote><pre><code>const obj &#x3D; {    get name (){        return &#39;jack&#39;    }}Object.assign({},obj)&#x3D;&gt;{name:&#39;jack&#39;}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;**Object.assign()**方法使用target的setter方法和origin对象的getter方法，复制对象可枚举的属性值，适用于很多的object操作。&lt;/p&gt;</summary>
    
    
    
    <category term="es6" scheme="https://hyong1232.github.io/categories/es6/"/>
    
    <category term="Object操作" scheme="https://hyong1232.github.io/categories/es6/Object%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="es6" scheme="https://hyong1232.github.io/tags/es6/"/>
    
    <category term="Object操作" scheme="https://hyong1232.github.io/tags/Object%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>es6编程风格</title>
    <link href="https://hyong1232.github.io/2020/09/23/es6-bian-cheng-feng-ge/"/>
    <id>https://hyong1232.github.io/2020/09/23/es6-bian-cheng-feng-ge/</id>
    <published>2020-09-23T02:52:07.000Z</published>
    <updated>2020-10-25T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于现行js的使用版本不一致，导致老版js和es6混用，以及es6本身的使用不规范，造成代码的格式不标准，不便于代码的维护和修改，故参考行业先进规范以改正。</p><a id="more"></a><h2 id="变量定义关键字替换"><a href="#变量定义关键字替换" class="headerlink" title="变量定义关键字替换"></a>变量定义关键字替换</h2><p>1、使用let取代var</p><ul><li>没有了变量提升，更严谨（存在temporal dead zone暂时性死区）需要先定义再使用。</li></ul><p>2、使用const声明全局常量</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>统一使用单引号，有变量的成分就是用反引号。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><blockquote><p>尽量使用结构赋值，保证简洁明了</p></blockquote><pre><code>&#x2F;&#x2F;常用于&#x2F;&#x2F;1、数组赋值const arr &#x3D; [1,2,3]const [one,two] &#x3D; arr&#x2F;&#x2F;2、获取函数参数function everyfunc(params){    const {one,two} &#x3D; params}&#x2F;&#x2F;3、函数返回值&amp;&amp;获取函数返回值（尽量使用对象返回结构，便于添加和修改顺序）const {one,two} &#x3D; getReturnFunc()function getReturnFunc(){    return {one,two}}</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>1、对象定义时，多行元素最后一个要加上‘,’，定义在一行上则不必</p><pre><code>const obj &#x3D; {a:1,b:3}const obj &#x3D; {    a:1,    b:3,}</code></pre><p>2、尽量不要修改，静态化，修改使用Object.assign(target,…origin)（可以有多个源对象）修改。</p><pre><code>const target &#x3D; {    one:&#39;one&#39;}Object.assign(target,{two:&#39;two&#39;})&#x3D;&#x3D;&#x3D;&gt;target&#x3D;{one:&#39;one&#39;,two:&#39;two&#39;}</code></pre><p>3、如果定义时元素名称不确定，使用属性表达式，即‘[要运算的表达式]’作为元素名称。</p><pre><code>const obj &#x3D; {    [getName(&#39;key&#39;)]:&#39;jack&#39;}</code></pre><p>4、对象内部方法省略function关键字，同名键名称省略</p><pre><code>const obj &#x3D; {    one,    get(){        ...    }}</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1、复制数组使用扩展运算符</p><pre><code>let oldArr &#x3D; [1,2]let newArr &#x3D; [...oldArr]</code></pre><p>2、将类数组转换成数组使用Array.from(target)target需要是可迭代的对象（有length属性）</p><pre><code>Array.from(document.querySelector(&#39;li&#39;))</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1、箭头函数</p><ul><li><p>简单的函数</p><pre><code>;[1, 2, 3].map(x &#x3D;&gt; x * x)</code></pre></li><li><p>绑定this值，代替使用（_self/that/_this）表示this</p><pre><code>&#x2F;&#x2F; badconst self &#x3D; this;const boundMethod &#x3D; function(...params) {  return method.apply(self, params);}&#x2F;&#x2F; acceptableconst boundMethod &#x3D; method.bind(this);&#x2F;&#x2F; bestconst boundMethod &#x3D; (...params) &#x3D;&gt; method.apply(this, params);</code></pre></li></ul><p>2、参数</p><ul><li><p>不用argument关键字，获取参数使用（…params）直接获取参数数组</p><pre><code>function(...params){    params.join(&#39;&#39;)}</code></pre></li><li><p>在参数列表设置默认参数</p><pre><code>function(params&#x3D;{}){}</code></pre></li></ul><h2 id="使用Map代替Object对象的使用"><a href="#使用Map代替Object对象的使用" class="headerlink" title="使用Map代替Object对象的使用"></a>使用Map代替Object对象的使用</h2><blockquote><p>Map有key:value结构，有自己的遍历方法，object使用在具体业务特殊对象。</p></blockquote><pre><code>let map &#x3D; new Map(可迭代对象)let map &#x3D; new Map([[1,&#39;one&#39;],[2,&#39;two&#39;]])&#x2F;&#x2F;keys()便利key值for key of map.keys(){} ;&#x2F;&#x2F;values()便利值&#x2F;&#x2F;entries()获取值和key值（为数组则是下标数值）</code></pre><h2 id="class代替原有的直接操作Prototype属性，规范类定义使用"><a href="#class代替原有的直接操作Prototype属性，规范类定义使用" class="headerlink" title="class代替原有的直接操作Prototype属性，规范类定义使用"></a>class代替原有的直接操作Prototype属性，规范类定义使用</h2><pre><code>&#x2F;&#x2F; badconst inherits &#x3D; require(&#39;inherits&#39;);function PeekableQueue(contents) {  Queue.apply(this, contents);}inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek &#x3D; function() {  return this._queue[0];}&#x2F;&#x2F; goodclass PeekableQueue extends Queue {  peek() {    return this._queue[0];  }}</code></pre><h2 id="使用es6的模块化代替CommonJS的模块化引用"><a href="#使用es6的模块化代替CommonJS的模块化引用" class="headerlink" title="使用es6的模块化代替CommonJS的模块化引用"></a>使用es6的模块化代替CommonJS的模块化引用</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;由于现行js的使用版本不一致，导致老版js和es6混用，以及es6本身的使用不规范，造成代码的格式不标准，不便于代码的维护和修改，故参考行业先进规范以改正。&lt;/p&gt;</summary>
    
    
    
    <category term="es6" scheme="https://hyong1232.github.io/categories/es6/"/>
    
    <category term="编程风格/规范" scheme="https://hyong1232.github.io/categories/es6/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC-%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="es6" scheme="https://hyong1232.github.io/tags/es6/"/>
    
    <category term="编程风格" scheme="https://hyong1232.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>java-day7</title>
    <link href="https://hyong1232.github.io/2020/09/22/java-day7/"/>
    <id>https://hyong1232.github.io/2020/09/22/java-day7/</id>
    <published>2020-09-22T14:40:05.000Z</published>
    <updated>2020-10-25T14:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是集合内容，linklist以及ArrayList对比，应用场景的区分。</p><a id="more"></a><ul><li>Java中没有引用传递都是值传递</li></ul><h4 id="LinkedList使用"><a href="#LinkedList使用" class="headerlink" title="LinkedList使用"></a>LinkedList使用</h4><ul><li>双向链表，头部和尾部相互引用</li><li>操作头/尾数据效率高，中间效率低 </li></ul><p>1、常用api</p><table><thead><tr><th>api</th><th>释义</th><th>返回值</th></tr></thead><tbody><tr><td>add(elem)</td><td>添加list元素</td><td>返回Boolean值，成功true</td></tr><tr><td>get(num)</td><td>通过下标来获取数组元素</td><td>对应元素</td></tr><tr><td>remove(num)</td><td>删除指定位置元素</td><td>删除的元素</td></tr><tr><td>remove(elem)</td><td>删除重载方法</td><td>返回Boolean值，删除了为true</td></tr><tr><td>size()</td><td>list大小</td><td>数字</td></tr><tr><td>iterator()</td><td>生成iterator对象</td><td>一个Iterator对象</td></tr></tbody></table><p>2、特性</p><ul><li><p>头/尾部两端效率高，中间效率低，由于内部结构是双向链表，可当作栈或队列stac/queue使用<br>  1、当普通双向链表时</p><table><thead><tr><th>api</th><th>释义</th></tr></thead><tbody><tr><td>addFirst(elem)</td><td>添加到头部</td></tr><tr><td>getFirst()</td><td>获取第一个元素</td></tr><tr><td>removeFirst()</td><td>删除第一个元素</td></tr><tr><td>addLast(elem)</td><td>添加到尾部</td></tr><tr><td>getLast()</td><td>获取最后一个元素</td></tr><tr><td>removeLast()</td><td>删除最后一个元素</td></tr></tbody></table><p>  2、当成queue队列时</p><table><thead><tr><th>api</th><th>释义</th></tr></thead><tbody><tr><td>offer(elem)</td><td>添加到头部</td></tr><tr><td>peek()</td><td>获取第一个元素</td></tr><tr><td>poll()</td><td>删除第一个元素</td></tr></tbody></table><p>  3、当成stack栈时</p><table><thead><tr><th>api</th><th>释义</th></tr></thead><tbody><tr><td>posh(elem)</td><td>添加到头部</td></tr><tr><td>pop()</td><td>删除第一个元素</td></tr></tbody></table></li><li><p>下标遍历效率低，使用iterator()方法生成迭代器对象，用迭代器的hasNext+next()方法遍历效率相对高。</p></li><li><p>iterator迭代器对象中存了list元素的引用，调用next方法自动引用元素值，同时将保存的引用换成下一个元素的。</p></li></ul><h3 id="和ArrayList对比"><a href="#和ArrayList对比" class="headerlink" title="和ArrayList对比"></a>和ArrayList对比</h3><ul><li>LinkedList适用于频繁的修改、添加头尾数据（丑数），获取数据较之慢</li><li>ArrayList适用于海量数据的查询（可直接由内存大小算出存储元素的地址，因此快），数据添加（添加至末尾）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;主要是集合内容，linklist以及ArrayList对比，应用场景的区分。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>babel使用介绍</title>
    <link href="https://hyong1232.github.io/2020/09/21/babel-shi-yong-jie-shao/"/>
    <id>https://hyong1232.github.io/2020/09/21/babel-shi-yong-jie-shao/</id>
    <published>2020-09-21T07:08:19.000Z</published>
    <updated>2020-10-25T14:50:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>babel+webpack作为es6必用的工具，配置和使用较为麻烦，小节了一下常见的使用和配置。</p><a id="more"></a><h3 id="配置在项目中使用"><a href="#配置在项目中使用" class="headerlink" title="配置在项目中使用"></a>配置在项目中使用</h3><blockquote><p>可使用配置文件.babelrc将常见配置写入文件中（放置在项目的根目录下），再webpack打包的过程中，会自动读取这个文件的配置，常见的配置写法如下:</p></blockquote><pre><code>{    &quot;presets&quot;:[&#39;es2015&#39;,&#39;env&#39;,&#39;stage-0&#39;],    &quot;plugins&quot;:[&#39;transform-runtime&#39;]}</code></pre><ul><li>.babelrc文件整个就是一个对象，在对象{}中配置相应的属性即可</li><li>常用的presets规则以及转换插件需要自行下载（npm命令即可）</li></ul><p><strong>babel配置也可以在webpack的配置文件中配置，即在module下的rules数组对象的规则对象的use属性中添加options属性中添加即可</strong></p><pre><code>module:{    rules:[        {            test:&#x2F;\.js$&#x2F;,            exclude:&#x2F;node_modules&#x2F;,            use:{                loader:&#39;babel-loader&#39;,                options:{                    presets:[&#39;env&#39;],                    plugins:[&#39;transform-runtime&#39;]                }            }        }    ]}</code></pre><p><strong>关于转换规则stage-0/1/2…在新的webpack中不在推荐使用，避免过多使用</strong></p><h3 id="命令行中直接转换"><a href="#命令行中直接转换" class="headerlink" title="命令行中直接转换"></a>命令行中直接转换</h3><blockquote><p>除了在项目中使用还可以直接在命令行转换es6的代码</p></blockquote><p>1、安装@babel/cli</p><pre><code>npm i -D @babel&#x2F;cli</code></pre><p>2、基本用法</p><pre><code>&#x2F;&#x2F;转换单个es6语法的文件到指定文件夹npx babel es6.js --out-file out.js&#x2F;&#x2F;简写为npx babel es6.js -o out.js&#x2F;&#x2F;转换文件夹至指定路径输出npx babel es6dir -out-dir outdir&#x2F;&#x2F;简写为npx babel es6dir -d outdir&#x2F;&#x2F;加上 -s参数生产source map文件npx babel es6dir -d outdir -s</code></pre><ul><li>转换文件到目标文件/文件夹时，没有会自动创建</li><li>文件夹转换是将源文件夹中的文件依次转换到对应的输出，出错则停止转换</li><li>关于npx可见<blockquote><p>常见的npx使用方式</p><footer><strong>阮一峰</strong><cite><a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">npx使用教程</a></cite></footer></blockquote></li><li>关于sourceMap可见<blockquote><p>sourceMap介绍</p><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></cite></footer></blockquote></li></ul><h3 id="babel-node的使用"><a href="#babel-node的使用" class="headerlink" title="@babel/node的使用"></a>@babel/node的使用</h3><blockquote><p>安装了这个包就可以在命令行直接执行es6命令，或者直接运行es6文件</p></blockquote><pre><code>&#x2F;&#x2F;直接运行es6文件npx node-node es6.js</code></pre><h3 id="babel-register"><a href="#babel-register" class="headerlink" title="@babel/register"></a>@babel/register</h3><blockquote><p>这个包的作用是在文件中对通过require加载的文件进行实时转换</p></blockquote><pre><code>&#x2F;&#x2F;安装npm i @babel&#x2F;register -D&#x2F;&#x2F;使用（文件中）require(&#39;@babel&#x2F;register&#39;);require(&#39;.&#x2F;es6.js&#39;)&#x2F;&#x2F;上述代码会自动将加载的es6文件转换</code></pre><ul><li>此包仅在运行时有效（适用于开发时使用）</li><li>使用时要先加载此包，放在文件的顶部</li><li>当前文件不会自动转换，只会转换require加载的文件（加一个钩子）</li></ul><h3 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h3><blockquote><p>babel默认不会转换es6新的api，只会转换语法（syntax）例如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promies等全局对象，及部分全局对象的工具方法例如Array.from()方法。使用polyfill可解决这个问题</p></blockquote><pre><code>&#x2F;&#x2F;安装(regenerator是转换generator的包)npm i core-js regenerator-runtime -D&#x2F;&#x2F;使用（文件中）导入即可（require&#x2F;import）import &#39;core-js&#39;import &#39;regenerator-runtime&#x2F;runtime&#39;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;babel+webpack作为es6必用的工具，配置和使用较为麻烦，小节了一下常见的使用和配置。&lt;/p&gt;</summary>
    
    
    
    <category term="es6" scheme="https://hyong1232.github.io/categories/es6/"/>
    
    <category term="babel" scheme="https://hyong1232.github.io/categories/es6/babel/"/>
    
    
    <category term="es6" scheme="https://hyong1232.github.io/tags/es6/"/>
    
    <category term="babel" scheme="https://hyong1232.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://hyong1232.github.io/2020/09/21/zheng-ze-biao-da-shi/"/>
    <id>https://hyong1232.github.io/2020/09/21/zheng-ze-biao-da-shi/</id>
    <published>2020-09-21T07:08:19.000Z</published>
    <updated>2020-10-25T14:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式的基本含义，常用语法的总结</p><a id="more"></a><h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>1、基本正则字符</p><table><thead><tr><th>表达式</th><th>匹配字符</th><th>等同写法</th></tr></thead><tbody><tr><td>abc</td><td>abc</td><td>-</td></tr><tr><td>[abc]</td><td>a,b,c中的一个</td><td>-</td></tr><tr><td>[abc][123]</td><td>a1,b1,c1,a2,b2,c2,a3,b3,c3中的一个</td><td>-</td></tr><tr><td>[^a-zA-Z]</td><td>非英文字母</td><td>-</td></tr><tr><td>[\u4e00-\u9fa5]</td><td>所有中文</td><td>-</td></tr><tr><td>\d</td><td>数字</td><td>[0-9]</td></tr><tr><td>\D</td><td>非数字</td><td>[^0-9]</td></tr><tr><td>\s</td><td>空白字符</td><td>-</td></tr><tr><td>\S</td><td>非空白字符</td><td>-</td></tr><tr><td>\w</td><td>单词字符（包含下划线）</td><td>[a-zA-Z_0-9]</td></tr><tr><td>\W</td><td>空白字符</td><td>-</td></tr><tr><td>.</td><td>任意字符</td><td>-</td></tr></tbody></table><p>2、匹配字符数量</p><table><thead><tr><th>表达式</th><th>匹配字符</th></tr></thead><tbody><tr><td>?</td><td>匹配1或0个字符</td></tr><tr><td>+</td><td>匹配起码&gt;=1个的字符</td></tr><tr><td>*</td><td>匹配任意数量字符</td></tr><tr><td>expression1|expression2</td><td>表达式1或表达式2成立都可算整个表达式成立</td></tr><tr><td>{num,}/{num}</td><td>指定匹配-大于num/num个字符（字符组合）</td></tr></tbody></table><ul><li>注意java的字符串中将/默认为转义字符，因此在定义正则时应该加双斜杠<pre><code>&#x2F;&#x2F;错误String regex &#x3D; &quot;\d{3}|\(\d{4}\)\d{6}&quot;;&#x2F;&#x2F;正确String regex &#x3D; &quot;\\d{3}|\\(\\d{4}\\)\\d{6}&quot;;</code></pre></li></ul><h2 id="常用api（主要在String类中使用）"><a href="#常用api（主要在String类中使用）" class="headerlink" title="常用api（主要在String类中使用）"></a>常用api（主要在String类中使用）</h2><p>1、String对象的api</p><table><thead><tr><th>表达式</th><th>释义</th><th>返回值</th></tr></thead><tbody><tr><td>matches(regex)</td><td>字符和正则规则比较</td><td>Boolean值</td></tr><tr><td>split(regex,[limitnum])</td><td>按照正则规则切分字符，返回数组</td><td>切分的数组</td></tr><tr><td>replaceAll(regex,replacement)</td><td>替换字符串中所有符合规则的字符</td><td>替换后的字符串</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;正则表达式的基本含义，常用语法的总结&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://hyong1232.github.io/categories/java/"/>
    
    <category term="正则" scheme="https://hyong1232.github.io/categories/java/%E6%AD%A3%E5%88%99/"/>
    
    
    <category term="java" scheme="https://hyong1232.github.io/tags/java/"/>
    
    <category term="正则" scheme="https://hyong1232.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>comonjs与ES6的文件导入导出比较</title>
    <link href="https://hyong1232.github.io/2020/09/20/comonjs-yu-es6-de-wen-jian-dao-ru-dao-chu-bi-jiao/"/>
    <id>https://hyong1232.github.io/2020/09/20/comonjs-yu-es6-de-wen-jian-dao-ru-dao-chu-bi-jiao/</id>
    <published>2020-09-20T09:22:04.000Z</published>
    <updated>2020-10-25T13:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>es6的模块化加载和node服务端的模块化加载，他们的关键字比较相近，而且在webpack打包的项目中，两种方式的模块化引用都是有效的，为了便于区分，小结了一下。</p><a id="more"></a><h2 id="CommonJS模块化加载"><a href="#CommonJS模块化加载" class="headerlink" title="CommonJS模块化加载"></a>CommonJS模块化加载</h2><blockquote><p>只有在运行时才会加载（同步加载），而且是加载整个路径的文件生成一个对象，然后再从这个对象中解构赋值给要查找的属性,例如：</p></blockquote><pre><code>let {a,b} &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F;等同于let _fs &#x3D; require(&#39;fs&#39;)let a &#x3D;  _fs.alet b &#x3D;  _fs.b</code></pre><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>1、导出单个对象时，给modules.exports对象直接赋值即可<br>2、导出多个对象时，使用关键字exports，将其看成对象，增加属性（为属性赋值）<br><strong>exports关键字只是modules.epxorts的引用，直接给exports赋值不会改变导出结果</strong></p><h3 id="导入require（）函数"><a href="#导入require（）函数" class="headerlink" title="导入require（）函数"></a>导入require（）函数</h3><p>1、运行时加载且为同步加载。<br>2、优先从缓存加载，重复文件不回加载。<br>3、循环加载时不会将父文件完整加载，而是只加载到调用自身时为止的内容，避免循环产生。<br>4、路径可为运行时才可得到的结果。</p><h2 id="ES6模块化加载"><a href="#ES6模块化加载" class="headerlink" title="ES6模块化加载"></a>ES6模块化加载</h2><blockquote><p>静态化思想，<strong>编译时</strong>就确定模块关系，即在模块内就指定要加载模块，运行时使用import加载指定的模块 </p></blockquote><pre><code>&#x2F;&#x2F;import {a,b} from &#39;fs&#39;</code></pre><p><strong>fs文件可以不写后缀需要在webpack中配置说明</strong></p><h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><blockquote><p>常见写法</p></blockquote><pre><code>export var a &#x3D; 1;export var b &#x3D; &#39;jack&#39;;&#x2F;&#x2F;相当于var a &#x3D; 1;var b &#x3D; &#39;jack&#39;export {a,b};&#x2F;&#x2F;函数或类export function exportFunc(){...}export class exportClass {...}&#x2F;&#x2F;使用as关键字为导出变量重命名,同一个导出变量可有多个不同名称的输出var a &#x3D; &#39;jack&#39;export {a as summer,a as peter};</code></pre><ul><li><p>通过export与import关键字进行导入导出，实际上就是导出了代码的引用到对应位置，因此他的数据是可变的（实时的）</p><pre><code>&#x2F;&#x2F;100ms之后导出的a的值会变成&#39;change&#39;var a &#x3D; &#39;origin&#39;setTimeout(_&#x3D;&gt;{a &#x3D; &#39;change&#39;},100)export {a};</code></pre></li><li><p>因为静态时确定模块导入/出关系，export关键字不可放在函数中，导出/导入表达式中不可有运行之后才有明确结果的变量成分</p></li><li><p>导出的结果为一个对象类型，若没有指定default导出，则不可单独导出其他类型</p></li></ul><h3 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h3><blockquote><p>常见写法</p></blockquote><pre><code>import {a,b} from &#39;.&#x2F;exprot.js&#39;&#x2F;&#x2F;可为导入的成员重新命名import {a as c,b as d} from &#39;.&#x2F;exprot.js&#39;&#x2F;&#x2F;导出变量如果不是对象，不可赋值（只读），是对象也不推荐赋值，影响代码维护import { a} form &#39;export.js&#39;a &#x3D; XXX——错误（不推荐）的写法</code></pre><ul><li><p>多次调用一个导入文件，等同于引用一个导出的多个被选引用，会自动合并相同引用例如</p><pre><code>import { foo } from &#39;my_module&#39;;import { bar } from &#39;my_module&#39;;&#x2F;&#x2F; 等同于import { foo, bar } from &#39;my_module&#39;;</code></pre></li><li><p>不要和CommonJS的模块加载混用，CommonJS是运行时加载会出问题</p></li></ul><h3 id="特殊导入-导出"><a href="#特殊导入-导出" class="headerlink" title="特殊导入/导出"></a>特殊导入/导出</h3><p>1、导入*——将整体导入成一个对象（但不可为对象属性赋值），可用as重命名</p><pre><code>import * as circle from &#39;.&#x2F;circle&#39;;&#x2F;&#x2F; 下面两行都是不允许的circle.foo &#x3D; &#39;hello&#39;;circle.area &#x3D; function () {};</code></pre><p>2、默认导入关键字default——导出default名称的变量，导入时可自由命名，不用使用as</p><blockquote><p>常见写法</p></blockquote><pre><code>&#x2F;&#x2F;导出命名函数——同导出匿名函数一样，名称无用，导入时自用命名exprot default function f(){...}&#x2F;&#x2F;等同于exprot default function (){...}&#x2F;&#x2F;导入时不用加{}import anyname from &#39;default.js&#39;&#x2F;&#x2F;上述操作等同于var something&#x3D; &#39;...&#39;exprot {something as default} import {default as anyname}</code></pre><ul><li>默认导入/导出可与导出对象叠加使用<pre><code>&#x2F;&#x2F;导出eport default function (obj) {···}export function each(obj, iterator, context) {...}export { each as forEach };&#x2F;&#x2F;导入import _, { each, forEach } from &#39;export.js&#39;;</code></pre></li></ul><p>3、合并import+export做转发or重命名or模块继承（添加完善）</p><pre><code>&#x2F;&#x2F;模块转发export { foo, bar } from &#39;my_module&#39;;&#x2F;&#x2F; 可以简单理解为import { foo, bar } from &#39;my_module&#39;;export { foo, bar };&#x2F;&#x2F;模块转发并重命名export * as ns from &quot;mod&quot;;&#x2F;&#x2F; 等同于import * as ns from &quot;mod&quot;;export {ns};&#x2F;&#x2F;模块继承（*号表示非默认default导出的对象）export * from &#39;circle&#39;;&#x2F;&#x2F;不包括default默认导出export var e &#x3D; 2.71828182846;export default function(x) {  return Math.exp(x);}&#x2F;&#x2F;引用修改（加强）的模块import * as math from &#39;circleplus&#39;;import exp from &#39;circleplus&#39;;&#x2F;&#x2F;上面继承模块默认导出的对象引用（函数）console.log(exp(math.e));   </code></pre><h3 id="import（）函数"><a href="#import（）函数" class="headerlink" title="import（）函数"></a>import（）函数</h3><blockquote><p>es2020添加了类似require的动态加载模块功能，返回一个promise对象，而加载成功则引用模块作为对象参数返回给回调函数</p></blockquote><pre><code>&#x2F;&#x2F;常见写法Promise.all([  import(&#39;.&#x2F;module1.js&#39;),  import(&#39;.&#x2F;module2.js&#39;),  import(&#39;.&#x2F;module3.js&#39;),]).then(([module1, module2, module3]) &#x3D;&gt; {   ···});&#x2F;&#x2F;导入模块后直接解构获取值import(&#39;.&#x2F;myModule.js&#39;).then(({export1, export2}) &#x3D;&gt; {  &#x2F;&#x2F; ...·});&#x2F;&#x2F;获取默认导出import(&#39;.&#x2F;myModule.js&#39;).then(myModule &#x3D;&gt; {  console.log(myModule.default);});&#x2F;&#x2F;默认导出的具名形式import(&#39;.&#x2F;myModule.js&#39;).then(({default: theDefault}) &#x3D;&gt; {  console.log(theDefault);});</code></pre><blockquote><p>总结特点：1、加载路径可变，动态加载引用2、可在函数内使用3、异步加载</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;es6的模块化加载和node服务端的模块化加载，他们的关键字比较相近，而且在webpack打包的项目中，两种方式的模块化引用都是有效的，为了便于区分，小结了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="es6" scheme="https://hyong1232.github.io/categories/es6/"/>
    
    <category term="CommonJS模块化加载" scheme="https://hyong1232.github.io/categories/es6/CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BD/"/>
    
    
    <category term="es6" scheme="https://hyong1232.github.io/tags/es6/"/>
    
    <category term="node" scheme="https://hyong1232.github.io/tags/node/"/>
    
    <category term="CommonJS模块化加载" scheme="https://hyong1232.github.io/tags/CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java-day6</title>
    <link href="https://hyong1232.github.io/2020/09/15/java-day6/"/>
    <id>https://hyong1232.github.io/2020/09/15/java-day6/</id>
    <published>2020-09-15T15:14:47.000Z</published>
    <updated>2020-10-25T14:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>day6，upup~</p><a id="more"></a><h2 id="Date类的简单实用"><a href="#Date类的简单实用" class="headerlink" title="Date类的简单实用"></a>Date类的简单实用</h2><blockquote><p>SimpleDateFormat+Date类</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>内部类就是类里面嵌套了类</p></blockquote><table><thead><tr><th>普通内部类</th><th>静态内部类</th></tr></thead><tbody><tr><td>异</td><td>普通内部类只能由具体的外部类对象生成内部内对象，静态内部类则可以直接生成对象</td></tr><tr><td>同</td><td>在类的里面定义，引入有导入包+外部类名.内部类名两种方式</td></tr><tr><td>同</td><td>在内部类和其外部类中可以相互引用私有变量/方法，部手限制关键字影响</td></tr></tbody></table><blockquote><p>局部内部类</p></blockquote><p>1、使用场景，只出现一次，需要不确定的类型实现对象引用接口/父类方法<br>2、使用方式new +父类/接口名（）{}即可。<br><strong>限制</strong>：</p><ul><li>使用局部变量需要final关键字（jdk1.8后可省略）</li><li>声明只在定义的局部代码块中有效/可用，但对象地址可以传递出去——&gt;用对象实现方法调用（传递出去时返回类型使用父类声明即可）</li></ul><p><strong>应用</strong></p><ul><li>sort方法总的comparator接口对象</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;day6，upup~&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java-day5</title>
    <link href="https://hyong1232.github.io/2020/09/14/java-day5/"/>
    <id>https://hyong1232.github.io/2020/09/14/java-day5/</id>
    <published>2020-09-14T13:01:34.000Z</published>
    <updated>2020-10-25T14:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>day5，访问控制符&amp;接口</p><a id="more"></a><h2 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h2><blockquote><p>作用及范围</p></blockquote><table><thead><tr><th>符号</th><th>本类</th><th>本包</th><th>子类</th><th>无限制</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>-</td></tr><tr><td>default</td><td>√</td><td>√</td><td>-</td><td>-</td></tr><tr><td>private</td><td>√</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><blockquote><p>static关键字的使用时机：1.公用资源2.通用方法</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>常量+抽象方法<br>1、常量：在接口中定义的变量都是常量（自动加上public static final关键字）<br>2、抽象方法：自动加上（public abstract 关键字）</p></blockquote><ul><li>作用分离具体功能类和功能类——变形金刚和他的武器库，而使用功能类则为测试类。</li></ul><h2 id="面向对象OOP（Object-oriented-programming）"><a href="#面向对象OOP（Object-oriented-programming）" class="headerlink" title="面向对象OOP（Object-oriented programming）"></a>面向对象OOP（Object-oriented programming）</h2><blockquote><p>面向对象的三大原则——封装、继承、多态</p></blockquote><p>1、封装——类私有化——private</p><ul><li><p>构造方法—<strong>抽象类是有构造方法的，在实现他的子类创建对象的时候运行</strong>常用与给成员变量赋值</p></li><li><p>this指定当前对象的引用地址，构造方法之间的相互引用</p></li></ul><p>2、继承——子类继承父类功能，并扩展自己的功能<br>3、多态——子类重写了父类的方法，同一个父类不同的实现类。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;day5，访问控制符&amp;amp;接口&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://hyong1232.github.io/categories/java/"/>
    
    <category term="javase" scheme="https://hyong1232.github.io/categories/java/javase/"/>
    
    
    <category term="access-control-character" scheme="https://hyong1232.github.io/tags/access-control-character/"/>
    
    <category term="interface" scheme="https://hyong1232.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java-day4</title>
    <link href="https://hyong1232.github.io/2020/09/13/java-day4/"/>
    <id>https://hyong1232.github.io/2020/09/13/java-day4/</id>
    <published>2020-09-13T15:44:39.000Z</published>
    <updated>2020-10-25T14:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>day4，主要讲了String类&amp;局部/全局变量&amp;Array常见方法使用&amp;递归&amp;BufferReader/FileReader/FileWriter&amp;混合变量后的类加载顺序</p><a id="more"></a><h2 id="混合变量类加载顺序"><a href="#混合变量类加载顺序" class="headerlink" title="混合变量类加载顺序"></a>混合变量类加载顺序</h2><blockquote><p>Array.copyOf(original,newlength)<br>返回新数组，不改变原数组<br>新数组的长度可大于或小于原数组——&gt;数组的切割/增大容量</p></blockquote><blockquote><p>类加载<br>1、将父类加载到方法区，并为其静态变量分配内存空间<br>2、将子类加载到方法区，并为其静态变量分配内存空间<br>3、为父类的静态变量赋值&amp;执行父类静态代码块（无先后顺序）<br>4、为子类的静态变量赋值&amp;执行子类静态代码块（无先后顺序）</p></blockquote><blockquote><p>new新对象<br>5、在堆中创建父类对象，为父类成员变量分配内存<br>6、在堆中创建子类对象，为子类成员变量分配内存<br>7、为父类的成员变量赋值<br>8、执行父类的构造函数<br>9、为子类的成员变量赋值<br>10、执行子类的构造函数</p></blockquote><p>binarySearch+ArrayList？？？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;day4，主要讲了String类&amp;amp;局部/全局变量&amp;amp;Array常见方法使用&amp;amp;递归&amp;amp;BufferReader/FileReader/FileWriter&amp;amp;混合变量后的类加载顺序&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://hyong1232.github.io/categories/java/"/>
    
    <category term="javase" scheme="https://hyong1232.github.io/categories/java/javase/"/>
    
    
    <category term="fileOperation" scheme="https://hyong1232.github.io/tags/fileOperation/"/>
    
    <category term="String" scheme="https://hyong1232.github.io/tags/String/"/>
    
    <category term="Arrays" scheme="https://hyong1232.github.io/tags/Arrays/"/>
    
  </entry>
  
  <entry>
    <title>java-day3</title>
    <link href="https://hyong1232.github.io/2020/09/08/java-day3/"/>
    <id>https://hyong1232.github.io/2020/09/08/java-day3/</id>
    <published>2020-09-08T14:15:04.000Z</published>
    <updated>2020-10-25T14:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>daythree，Java中的final变量，JVM堆栈区，binarysearch&amp;ArrayList的add方法，静态资源调用，代码块执行顺序<br>1、代码块执行顺序<br>2、重写listarray，并用cellction.binarysearch方法依次插入数据<br>3、输入整数，转换成byte数组，保存，查看使用静态代码块初始化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;daythree，Java中的final变量，JVM堆栈区，binarysearch&amp;amp;ArrayList的add方法，静态资源调用，</summary>
      
    
    
    
    <category term="java" scheme="https://hyong1232.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://hyong1232.github.io/tags/java/"/>
    
    <category term="final" scheme="https://hyong1232.github.io/tags/final/"/>
    
    <category term="static" scheme="https://hyong1232.github.io/tags/static/"/>
    
    <category term="JVM" scheme="https://hyong1232.github.io/tags/JVM/"/>
    
    <category term="Collection" scheme="https://hyong1232.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>scroll滚动</title>
    <link href="https://hyong1232.github.io/2020/09/08/scroll-gun-dong/"/>
    <id>https://hyong1232.github.io/2020/09/08/scroll-gun-dong/</id>
    <published>2020-09-08T06:12:08.000Z</published>
    <updated>2020-10-25T13:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单总结一下js的ceilheight&amp;offsetheight的关系，以及scroll的使用方法</p><a id="more"></a><h2 id="clientHeight-amp-offsetHeight-amp-scrollHeight"><a href="#clientHeight-amp-offsetHeight-amp-scrollHeight" class="headerlink" title="clientHeight&amp;offsetHeight&amp;scrollHeight"></a>clientHeight&amp;offsetHeight&amp;scrollHeight</h2><p>1、常见的scrollHeight指的就是文本要放置的最小高度，包含被滚动条遮挡的未显示的部分<br><img src="/images/scrollHeight.webp" alt="scollHeight"></p><p>2、clientHeight指的是当前可视部分（可以直接看到的文本内容窗口大小）<br><img src="/images/clientHeight.webp" alt="clientHeight&amp;&amp;offsetHeight"></p><p>3、offsetHeight则是包含了可见部分的滚动条宽度和可视文本部分</p><h2 id="scrollTop-amp-amp-offsetTop"><a href="#scrollTop-amp-amp-offsetTop" class="headerlink" title="scrollTop&amp;&amp;offsetTop"></a>scrollTop&amp;&amp;offsetTop</h2><p>1、scrollTop指的是所有文本高度到可是部分的顶点的高度</p><p>2、offsetHeight指的是父级设置了position属性的节点到本节点顶部的距离，若没有设置position则默认body到元素顶部的偏移量</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;简单总结一下js的ceilheight&amp;amp;offsetheight的关系，以及scroll的使用方法&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://hyong1232.github.io/categories/javascript/"/>
    
    <category term="css" scheme="https://hyong1232.github.io/categories/javascript/css/"/>
    
    
    <category term="css" scheme="https://hyong1232.github.io/tags/css/"/>
    
    <category term="css-layout" scheme="https://hyong1232.github.io/tags/css-layout/"/>
    
    <category term="javascript" scheme="https://hyong1232.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
